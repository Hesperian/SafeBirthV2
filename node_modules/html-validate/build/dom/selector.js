"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const combinator_1 = require("./combinator");
class Matcher {
    match(node) {
        return false;
    }
}
class ClassMatcher extends Matcher {
    constructor(classname) {
        super();
        this.classname = classname;
    }
    match(node) {
        return node.classList.contains(this.classname);
    }
}
class IdMatcher extends Matcher {
    constructor(id) {
        super();
        this.id = id;
    }
    match(node) {
        return node.id === this.id;
    }
}
class AttrMatcher extends Matcher {
    constructor(attr) {
        super();
        const [, key, op, value] = attr.match(/^(.+?)(?:([~^$*|]?=)"([a-z]+)")?$/);
        this.key = key;
        this.op = op;
        this.value = value;
    }
    match(node) {
        const attr = node.getAttributeValue(this.key);
        switch (this.op) {
            case undefined:
                return attr !== null;
            case '=':
                return attr === this.value;
            default:
                throw new Error(`Attribute selector operator ${this.op} is not implemented yet`);
        }
    }
}
class Pattern {
    constructor(pattern) {
        const match = pattern.match(/^([~+\->]?)((?:[*]|[^.#[]+)?)(.*)$/);
        match.shift();
        this.selector = pattern;
        this.combinator = combinator_1.parseCombinator(match.shift());
        this.tagName = match.shift() || '*';
        const p = match[0] ? match[0].split(/(?=[.#[])/) : [];
        this.pattern = p.map((cur) => Pattern.createMatcher(cur));
    }
    match(node) {
        return node.is(this.tagName) && this.pattern.every((cur) => cur.match(node));
    }
    static createMatcher(pattern) {
        switch (pattern[0]) {
            case '.':
                return new ClassMatcher(pattern.slice(1));
            case '#':
                return new IdMatcher(pattern.slice(1));
            case '[':
                return new AttrMatcher(pattern.slice(1, -1));
            default:
                throw new Error(`Failed to create matcher for "${pattern}"`);
        }
    }
}
class Selector {
    constructor(selector) {
        this.pattern = Selector.parse(selector);
    }
    *match(root, level = 0) {
        if (level >= this.pattern.length) {
            yield root;
            return;
        }
        const pattern = this.pattern[level];
        const matches = Selector.findCandidates(root, pattern);
        for (const node of matches) {
            if (!pattern.match(node)) {
                continue;
            }
            yield* this.match(node, level + 1);
        }
    }
    static parse(selector) {
        const pattern = selector.replace(/([+~>]) /, '$1').split(/ +/);
        return pattern.map((part) => new Pattern(part));
    }
    static findCandidates(root, pattern) {
        switch (pattern.combinator) {
            case combinator_1.Combinator.DESCENDANT:
                return root.getElementsByTagName(pattern.tagName);
            case combinator_1.Combinator.CHILD:
                return root.children.filter(node => node.is(pattern.tagName));
            case combinator_1.Combinator.ADJACENT_SIBLING:
                return Selector.findAdjacentSibling(root);
            case combinator_1.Combinator.GENERAL_SIBLING:
                return Selector.findGeneralSibling(root);
        }
        return [];
    }
    static findAdjacentSibling(node) {
        let adjacent = false;
        return node.siblings.filter(cur => {
            if (adjacent) {
                adjacent = false;
                return true;
            }
            if (cur === node) {
                adjacent = true;
            }
            return false;
        });
    }
    static findGeneralSibling(node) {
        let after = false;
        return node.siblings.filter(cur => {
            if (after) {
                return true;
            }
            if (cur === node) {
                after = true;
            }
            return false;
        });
    }
}
exports.Selector = Selector;
