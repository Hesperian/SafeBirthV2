"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dom_1 = require("../dom");
const lexer_1 = require("../lexer");
const event_1 = require("../event");
class Parser {
    constructor(config) {
        this.config = config;
        this.event = new event_1.EventHandler();
        this.dom = undefined;
        this.metaTable = config.getMetaTable();
    }
    parseHtml(source) {
        if (typeof source === 'string') {
            source = {
                data: source,
                filename: 'inline',
                line: 1,
                column: 1,
            };
        }
        this.dom = new dom_1.DOMTree({
            filename: source.filename,
            offset: 0,
            line: source.line,
            column: source.column,
        });
        this.trigger('dom:load', {
            location: null,
        });
        const lexer = new lexer_1.Lexer();
        const tokenStream = lexer.tokenize(source);
        let it = this.next(tokenStream);
        while (!it.done) {
            const token = it.value;
            switch (token.type) {
                case lexer_1.TokenType.TAG_OPEN:
                    this.consumeTag(token, tokenStream);
                    break;
                case lexer_1.TokenType.WHITESPACE:
                    this.trigger('whitespace', {
                        text: token.data[0],
                        location: token.location,
                    });
                    break;
                case lexer_1.TokenType.DIRECTIVE:
                    this.consumeDirective(token);
                    break;
                case lexer_1.TokenType.CONDITIONAL:
                    this.trigger('conditional', {
                        condition: token.data[1],
                        location: token.location,
                    });
                    break;
                case lexer_1.TokenType.DOCTYPE_OPEN:
                    this.consumeDoctype(token, tokenStream);
                    break;
                case lexer_1.TokenType.EOF:
                    this.closeTree(token);
                    break;
            }
            it = this.next(tokenStream);
        }
        this.dom.resolveMeta(this.metaTable);
        this.trigger('dom:ready', {
            document: this.dom,
            location: null,
        });
        return this.dom;
    }
    closeOptional(token) {
        const active = this.dom.getActive();
        if (!(active.meta && active.meta.implicitClosed)) {
            return false;
        }
        const tagName = token.data[2];
        const open = !token.data[1];
        const meta = active.meta.implicitClosed;
        if (open) {
            return meta.indexOf(tagName) >= 0;
        }
        else {
            if (active.is(tagName)) {
                return false;
            }
            return active.parent.is(tagName) && meta.indexOf(active.tagName) >= 0;
        }
    }
    consumeTag(startToken, tokenStream) {
        const tokens = Array.from(this.consumeUntil(tokenStream, lexer_1.TokenType.TAG_CLOSE));
        const endToken = tokens.slice(-1)[0];
        const closeOptional = this.closeOptional(startToken);
        const parent = closeOptional ? this.dom.getActive().parent : this.dom.getActive();
        const node = dom_1.DOMNode.fromTokens(startToken, endToken, parent, this.metaTable);
        const open = !startToken.data[1];
        const close = !open || node.closed !== dom_1.NodeClosed.Open;
        if (closeOptional) {
            const active = this.dom.getActive();
            active.closed = dom_1.NodeClosed.ImplicitClosed;
            this.trigger('tag:close', {
                target: node,
                previous: active,
                location: startToken.location,
            });
            this.dom.popActive();
        }
        if (open) {
            this.dom.pushActive(node);
            this.trigger('tag:open', {
                target: node,
                location: startToken.location,
            });
        }
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            switch (token.type) {
                case lexer_1.TokenType.WHITESPACE:
                    break;
                case lexer_1.TokenType.ATTR_NAME:
                    this.consumeAttribute(node, token, tokens[i + 1]);
                    break;
            }
        }
        if (close) {
            const active = this.dom.getActive();
            if (!open) {
                node.closed = dom_1.NodeClosed.EndTag;
            }
            this.trigger('tag:close', {
                target: node,
                previous: active,
                location: endToken.location,
            });
            const voidClosed = !open && node.voidElement;
            if (!voidClosed) {
                this.dom.popActive();
            }
        }
    }
    consumeAttribute(node, token, next) {
        const key = token.data[1];
        let value = undefined;
        let quote = undefined;
        if (next && next.type === lexer_1.TokenType.ATTR_VALUE) {
            value = next.data[1];
            quote = next.data[2];
        }
        this.trigger('attr', {
            target: node,
            key,
            value,
            quote,
            location: token.location,
        });
        node.setAttribute(key, value, token.location);
    }
    consumeDirective(token) {
        const directive = token.data[1];
        const match = directive.match(/^([a-zA-Z0-9-]+)\s*(.*?)(?:\s*:\s*(.*))?$/);
        if (!match) {
            throw new Error(`Failed to parse directive "${directive}"`);
        }
        const [, action, data, comment] = match;
        this.trigger('directive', {
            action,
            data,
            comment: comment || '',
            location: token.location,
        });
    }
    consumeDoctype(startToken, tokenStream) {
        const tokens = Array.from(this.consumeUntil(tokenStream, lexer_1.TokenType.DOCTYPE_CLOSE));
        const doctype = tokens[0];
        const value = doctype.data[0];
        this.dom.doctype = value;
        this.trigger('doctype', {
            value,
            location: startToken.location,
        });
    }
    *consumeUntil(tokenStream, search) {
        let it = this.next(tokenStream);
        while (!it.done) {
            const token = it.value;
            yield token;
            if (token.type === search)
                return;
            it = this.next(tokenStream);
        }
        throw Error('stream ended before consumeUntil finished');
    }
    next(tokenStream) {
        return tokenStream.next();
    }
    on(event, listener) {
        return this.event.on(event, listener);
    }
    once(event, listener) {
        return this.event.once(event, listener);
    }
    defer(cb) {
        this.event.once('*', cb);
    }
    trigger(event, data) {
        if (typeof data.location === 'undefined') {
            throw Error('Triggered event must contain location');
        }
        this.event.trigger(event, data);
    }
    closeTree(token) {
        let active;
        while ((active = this.dom.getActive()) && active.tagName) {
            this.trigger('tag:close', {
                target: undefined,
                previous: active,
                location: token.location,
            });
            this.dom.popActive();
        }
    }
}
exports.Parser = Parser;
