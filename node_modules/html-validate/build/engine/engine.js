"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("../config");
const lexer_1 = require("../lexer");
const parser_1 = require("../parser");
const reporter_1 = require("../reporter");
const rule_1 = require("../rule");
class Engine {
    constructor(config, ParserClass) {
        this.report = new reporter_1.Reporter();
        this.config = config;
        this.ParserClass = ParserClass;
        this.availableRules = {};
        for (const plugin of (this.config.getPlugins())) {
            for (const [name, rule] of Object.entries(plugin.rules)) {
                this.availableRules[name] = rule;
            }
        }
    }
    lint(sources) {
        for (const source of sources) {
            const parser = new this.ParserClass(this.config);
            const rules = {};
            Object.entries(this.config.getRules()).map(([name, data]) => {
                rules[name] = this.loadRule(name, data, parser, this.report);
            });
            parser.on('directive', (_, event) => {
                this.processDirective(event, parser, rules);
            });
            try {
                parser.parseHtml(source);
            }
            catch (e) {
                if (e instanceof lexer_1.InvalidTokenError) {
                    this.reportError(e.message, e.location);
                }
                else {
                    throw e;
                }
            }
        }
        return this.report.save();
    }
    dumpEvents(source) {
        const parser = new parser_1.Parser(this.config);
        const lines = [];
        parser.on('*', (event, data) => {
            lines.push({ event, data });
        });
        source.forEach(src => parser.parseHtml(src));
        return lines;
    }
    dumpTokens(source) {
        const lexer = new lexer_1.Lexer();
        const lines = [];
        for (const src of source) {
            for (const token of lexer.tokenize(src)) {
                const data = token.data ? token.data[0] : null;
                lines.push({
                    token: lexer_1.TokenType[token.type],
                    data: data,
                    location: `${token.location.filename}:${token.location.line}:${token.location.column}`,
                });
            }
        }
        return lines;
    }
    dumpTree(source) {
        const parser = new parser_1.Parser(this.config);
        const dom = parser.parseHtml(source[0]);
        const lines = [];
        function decoration(node) {
            let output = '';
            if (node.hasAttribute('id')) {
                output += `#${node.id}`;
            }
            if (node.hasAttribute('class')) {
                output += `.${node.classList.join('.')}`;
            }
            return output;
        }
        function writeNode(node, level, sibling) {
            if (level > 0) {
                const indent = '  '.repeat(level - 1);
                const l = node.children.length > 0 ? '┬' : '─';
                const b = sibling < (node.parent.children.length - 1) ? '├' : '└';
                lines.push(`${indent}${b}─${l} ${node.tagName}${decoration(node)}`);
            }
            else {
                lines.push(`(root)`);
            }
            node.children.forEach((child, index) => writeNode(child, level + 1, index));
        }
        writeNode(dom.root, 0, 0);
        return lines;
    }
    processDirective(event, parser, allRules) {
        const rules = event.data
            .split(',')
            .map(name => name.trim())
            .map(name => allRules[name])
            .filter(rule => rule);
        switch (event.action) {
            case 'enable':
                this.processEnableDirective(rules);
                break;
            case 'disable':
                this.processDisableDirective(rules);
                break;
            case 'disable-block':
                this.processDisableBlockDirective(rules, parser);
                break;
            case 'disable-next':
                this.processDisableNextDirective(rules, parser);
                break;
            default:
                this.reportError(`Unknown directive "${event.action}"`, event.location);
                break;
        }
    }
    processEnableDirective(rules) {
        for (const rule of rules) {
            rule.setEnabled(true);
            if (rule.getSeverity() === config_1.Config.SEVERITY_DISABLED) {
                rule.setServerity(config_1.Config.SEVERITY_ERROR);
            }
        }
    }
    processDisableDirective(rules) {
        for (const rule of rules) {
            rule.setEnabled(false);
        }
    }
    processDisableBlockDirective(rules, parser) {
        let directiveBlock = null;
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        const unregisterOpen = parser.once('tag:open', (event, data) => {
            directiveBlock = data.target.parent.unique;
        });
        const unregisterClose = parser.on('tag:close', (event, data) => {
            if (directiveBlock === null) {
                unregisterClose();
                unregisterOpen();
                for (const rule of rules) {
                    rule.setEnabled(true);
                }
                return;
            }
            const currentBlock = data.previous.unique;
            if (currentBlock === directiveBlock) {
                unregisterClose();
                for (const rule of rules) {
                    rule.setEnabled(true);
                }
            }
        });
    }
    processDisableNextDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(false);
            parser.once('tag:open, tag:close, attr', () => {
                parser.defer(() => {
                    rule.setEnabled(true);
                });
            });
        }
    }
    loadRule(name, data, parser, report) {
        const [severity, options] = data;
        const rule = this.instantiateRule(name, options);
        rule.name = rule.name || name;
        rule.init(parser, report, severity);
        if (rule.setup) {
            rule.setup();
        }
        return rule;
    }
    instantiateRule(name, options) {
        if (this.availableRules[name]) {
            return new this.availableRules[name](options);
        }
        else {
            return this.requireRule(name, options) || this.missingRule(name);
        }
    }
    requireRule(name, options) {
        let Class;
        try {
            Class = require(`../rules/${name}`);
        }
        catch (e) {
            return null;
        }
        return new Class(options);
    }
    missingRule(name) {
        return new class extends rule_1.Rule {
            setup() {
                this.on('dom:load', () => {
                    this.report(null, `Definition for rule '${name}' was not found`);
                });
            }
        }({});
    }
    reportError(message, location) {
        this.report.addManual(location.filename, {
            ruleId: undefined,
            severity: config_1.Config.SEVERITY_ERROR,
            message: message,
            offset: location.offset,
            line: location.line,
            column: location.column,
            size: location.size || 0,
        });
    }
}
exports.Engine = Engine;
