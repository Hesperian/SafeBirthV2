"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const meta_1 = require("../meta");
const default_1 = require("./default");
const fs = require('fs');
const path = require('path');
const deepmerge = require('deepmerge');
const recommended = require('./recommended');
const document = require('./document');
function parseSeverity(value) {
    if (typeof value === 'number') {
        return value;
    }
    switch (value) {
        case 'off':
            return 0;
        case 'disable':
            console.warn(`Deprecated alias "disabled" will be removed, replace with severity "off"`);
            return 0;
        case 'warn':
            return 1;
        case 'error':
            return 2;
        default:
            throw new Error(`Invalid severity "${value}"`);
    }
}
class Config {
    constructor(options) {
        this.config = {
            extends: [],
            plugins: [],
            rules: {},
            transform: {},
        };
        this.mergeInternal(options || {});
        this.metaTable = null;
        this.rootDir = this.findRootDir();
        for (const extend of this.config.extends) {
            const base = Config.fromFile(extend);
            this.config = base.mergeInternal(this.config);
        }
    }
    static empty() {
        return new Config({
            extends: [],
            rules: {},
            plugins: [],
            transform: {},
        });
    }
    static fromObject(options) {
        return new Config(options);
    }
    static fromFile(filename) {
        switch (filename) {
            case 'htmlvalidate:recommended': return Config.fromObject(recommended);
            case 'htmlvalidate:document': return Config.fromObject(document);
        }
        const json = require(filename);
        for (const key of ['extends', 'elements', 'plugins']) {
            if (!json[key])
                continue;
            json[key] = json[key].map((ref) => {
                return Config.expandRelative(ref, path.dirname(filename));
            });
        }
        return new Config(json);
    }
    static defaultConfig() {
        return new Config(default_1.default);
    }
    init() {
        this.plugins = this.loadPlugins(this.config.plugins || []);
        this.transformers = this.precompileTransformers(this.config.transform || {});
    }
    merge(rhs) {
        return new Config(this.mergeInternal(rhs.config));
    }
    getMetaTable() {
        if (this.metaTable) {
            return this.metaTable;
        }
        this.metaTable = new meta_1.MetaTable();
        const source = this.config.elements || ['html5'];
        const root = path.resolve(__dirname, '..', '..');
        for (const entry of source) {
            if (typeof entry !== 'string') {
                this.metaTable.loadFromObject(entry);
                continue;
            }
            const filename = `${root}/elements/${entry}.json`;
            if (fs.existsSync(filename)) {
                this.metaTable.loadFromFile(filename);
                continue;
            }
            if (fs.existsSync(entry)) {
                this.metaTable.loadFromFile(entry);
                continue;
            }
            this.metaTable.loadFromObject(require(entry));
        }
        this.metaTable.init();
        return this.metaTable;
    }
    static expandRelative(src, currentPath) {
        if (src[0] === '.') {
            return path.normalize(`${currentPath}/${src}`);
        }
        return src;
    }
    mergeInternal(config) {
        this.config = deepmerge(this.config, config);
        return this.config;
    }
    get() {
        return Object.assign({}, this.config);
    }
    getRules() {
        const rules = Object.assign({}, this.config.rules || {});
        for (const name in rules) {
            let options = rules[name];
            if (!Array.isArray(options)) {
                options = [options, {}];
            }
            else if (options.length === 1) {
                options = [options[0], {}];
            }
            options[0] = parseSeverity(options[0]);
            rules[name] = options;
        }
        return rules;
    }
    getPlugins() {
        return this.plugins;
    }
    loadPlugins(plugins) {
        return plugins.map((name) => {
            return require(name);
        });
    }
    transform(filename) {
        const transformer = this.findTransformer(filename);
        if (transformer) {
            return transformer.fn(filename);
        }
        else {
            return [{
                    data: fs.readFileSync(filename, { encoding: 'utf8' }),
                    filename,
                    line: 1,
                    column: 1,
                }];
        }
    }
    findTransformer(filename) {
        return this.transformers.find((entry) => entry.pattern.test(filename));
    }
    precompileTransformers(transform) {
        return Object.entries(transform).map(([pattern, module]) => {
            return {
                pattern: new RegExp(pattern),
                fn: require(module.replace('<rootDir>', this.rootDir)),
            };
        });
    }
    findRootDir() {
        let current = process.cwd();
        for (;;) {
            const search = path.join(current, 'package.json');
            if (fs.existsSync(search)) {
                return current;
            }
            const child = current;
            current = path.dirname(current);
            if (current === child) {
                break;
            }
        }
        return process.cwd();
    }
}
Config.SEVERITY_DISABLED = 0;
Config.SEVERITY_WARN = 1;
Config.SEVERITY_ERROR = 2;
exports.Config = Config;
