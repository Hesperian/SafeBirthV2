"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const allowedKeys = [
    'exclude',
];
class Validator {
    static validatePermitted(node, rules) {
        if (!rules) {
            return true;
        }
        return rules.some(rule => {
            return Validator.validatePermittedRule(node, rule);
        });
    }
    static validateOccurrences(node, rules, numSiblings) {
        if (!rules) {
            return true;
        }
        const category = rules.find(cur => {
            if (typeof cur !== 'string') {
                return false;
            }
            const match = cur.match(/^(.*?)[?*]?$/);
            return match && match[1] === node.tagName;
        });
        const limit = parseAmountQualifier(category);
        return limit === null || numSiblings <= limit;
    }
    static validateOrder(children, rules, cb) {
        if (!rules) {
            return true;
        }
        let i = 0;
        let prev = null;
        for (const node of children) {
            const old = i;
            while (rules[i] && !Validator.validatePermittedCategory(node, rules[i])) {
                i++;
            }
            if (i >= rules.length) {
                const orderSpecified = rules.find((cur) => Validator.validatePermittedCategory(node, cur));
                if (orderSpecified) {
                    cb(node, prev);
                    return false;
                }
                i = old;
            }
            prev = node;
        }
        return true;
    }
    static validateAttribute(key, value, rules) {
        const rule = rules[key];
        if (!rule) {
            return true;
        }
        if (rule.length === 0) {
            return value === undefined || value === "" || value === key;
        }
        return rule.some((entry) => {
            if (entry instanceof RegExp) {
                return !!value.match(entry);
            }
            else {
                return value === entry;
            }
        });
    }
    static validatePermittedRule(node, rule) {
        if (typeof rule === 'string') {
            return Validator.validatePermittedCategory(node, rule);
        }
        else if (Array.isArray(rule)) {
            return rule.every((inner) => {
                return Validator.validatePermittedRule(node, inner);
            });
        }
        else {
            validateKeys(rule);
            if (rule.exclude) {
                if (Array.isArray(rule.exclude)) {
                    return !rule.exclude.some((inner) => {
                        return Validator.validatePermittedRule(node, inner);
                    });
                }
                else {
                    return !Validator.validatePermittedRule(node, rule.exclude);
                }
            }
            else {
                return false;
            }
        }
    }
    static validatePermittedCategory(node, category) {
        if (category[0] !== '@') {
            const [, tagName] = category.match(/^(.*?)[?*]?$/);
            return node.tagName === tagName;
        }
        if (!node.meta) {
            return true;
        }
        switch (category) {
            case '@meta': return node.meta.metadata;
            case '@flow': return node.meta.flow;
            case '@sectioning': return node.meta.sectioning;
            case '@heading': return node.meta.heading;
            case '@phrasing': return node.meta.phrasing;
            case '@embedded': return node.meta.embedded;
            case '@interactive': return node.meta.interactive;
            default: throw new Error(`Invalid content category "${category}"`);
        }
    }
}
exports.Validator = Validator;
function validateKeys(rule) {
    for (const key of Object.keys(rule)) {
        if (allowedKeys.indexOf(key) === -1) {
            const str = JSON.stringify(rule);
            throw new Error(`Permitted rule "${str}" contains unknown property "${key}"`);
        }
    }
}
function parseAmountQualifier(category) {
    if (!category) {
        return null;
    }
    const [, qualifier] = category.match(/^.*?([?*]?)$/);
    switch (qualifier) {
        case '?': return 1;
        case '': return null;
        case '*': return null;
        default:
            throw new Error(`Invalid amount qualifier "${qualifier}" used`);
    }
}
