"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deepmerge = require('deepmerge');
const allowedKeys = [
    'tagName',
    'metadata',
    'flow',
    'sectioning',
    'heading',
    'phrasing',
    'embedded',
    'interactive',
    'deprecated',
    'void',
    'transparent',
    'implicitClosed',
    'attributes',
    'deprecatedAttributes',
    'permittedContent',
    'permittedDescendants',
    'permittedOrder',
];
const dynamicKeys = [
    'metadata',
    'flow',
    'sectioning',
    'heading',
    'phrasing',
    'embedded',
    'interactive',
];
const functionTable = {
    isDescendant,
    hasAttribute,
    matchAttribute,
};
class MetaTable {
    constructor() {
        this.elements = {};
    }
    init() {
        this.resolveGlobal();
    }
    loadFromObject(obj) {
        for (const key of Object.keys(obj)) {
            this.addEntry(key, obj[key]);
        }
    }
    loadFromFile(filename) {
        this.loadFromObject(require(filename));
    }
    getMetaFor(tagName) {
        tagName = tagName.toLowerCase();
        return this.elements[tagName] ? Object.assign({}, this.elements[tagName]) : null;
    }
    addEntry(tagName, entry) {
        for (const key of Object.keys(entry)) {
            if (allowedKeys.indexOf(key) === -1) {
                throw new Error(`Metadata for <${tagName}> contains unknown property "${key}"`);
            }
        }
        const expanded = Object.assign({
            tagName,
            void: false,
        }, entry);
        expandRegex(expanded);
        this.elements[tagName] = expanded;
    }
    resolveGlobal() {
        if (!this.elements['*'])
            return;
        const global = this.elements['*'];
        delete this.elements['*'];
        delete global.tagName;
        delete global.void;
        for (const [tagName, entry] of Object.entries(this.elements)) {
            this.elements[tagName] = this.mergeElement(entry, global);
        }
    }
    mergeElement(a, b) {
        return deepmerge(a, b);
    }
    resolve(node) {
        if (node.meta) {
            expandProperties(node, node.meta);
        }
    }
}
exports.MetaTable = MetaTable;
function expandProperties(node, entry) {
    for (const key of dynamicKeys) {
        const property = entry[key];
        if (property && typeof property !== 'boolean') {
            entry[key] = evaluateProperty(node, property);
        }
    }
}
function expandRegex(entry) {
    if (!entry.attributes)
        return;
    for (const [name, values] of Object.entries(entry.attributes)) {
        entry.attributes[name] = values.map((value) => {
            const match = typeof value === 'string' && value.match(/^\/(.*)\/$/);
            if (match) {
                return new RegExp(match[1]);
            }
            else {
                return value;
            }
        });
    }
}
function evaluateProperty(node, expr) {
    const [func, options] = parseExpression(expr);
    return func(node, options);
}
function parseExpression(expr) {
    if (typeof expr === 'string') {
        return parseExpression([expr, {}]);
    }
    else {
        const [funcName, options] = expr;
        const func = functionTable[funcName];
        if (!func) {
            throw new Error(`Failed to find function "${funcName}" when evaluating property expression`);
        }
        return [func, options];
    }
}
function isDescendant(node, tagName) {
    if (typeof tagName !== 'string') {
        throw new Error(`Property expression "isDescendant" must take string argument when evaluating metadata for <${node.tagName}>`);
    }
    let cur = node.parent;
    while (!cur.isRootElement()) {
        if (cur.is(tagName)) {
            return true;
        }
        cur = cur.parent;
    }
    return false;
}
function hasAttribute(node, attr) {
    if (typeof attr !== 'string') {
        throw new Error(`Property expression "hasAttribute" must take string argument when evaluating metadata for <${node.tagName}>`);
    }
    return node.hasAttribute(attr);
}
function matchAttribute(node, match) {
    if (!Array.isArray(match) || match.length !== 3) {
        throw new Error(`Property expression "matchAttribute" must take [key, op, value] array as argument when evaluating metadata for <${node.tagName}>`);
    }
    const [key, op, value] = match.map(x => x.toLowerCase());
    const nodeValue = (node.getAttributeValue(key) || '').toLowerCase();
    switch (op) {
        case '!=': return nodeValue !== value;
        case '=': return nodeValue === value;
        default: throw new Error(`Property expression "matchAttribute" has invalid operator "${op}" when evaluating metadata for <${node.tagName}>`);
    }
}
